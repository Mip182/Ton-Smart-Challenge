{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

() recv_internal() {
}

builder begin_cell() asm "NEWC";
cell end_cell(builder b) asm "ENDC";
slice begin_parse(cell c) asm "CTOS";
int slice_refs_empty?(slice s) asm "SREMPTY";
int slice_bits(slice s) asm "SBITS";
(slice, ()) ~skip_bits(slice s, int len) asm "SDSKIPFIRST";
forall X -> (tuple, ()) ~tpush(tuple t, X value) asm "TPUSH";
tuple empty_tuple() asm "NIL";
(slice, cell) load_ref(slice s) asm(-> 1 0) "LDREF";
(int) tlen(tuple t) asm "TLEN";
builder store_ref(builder b, cell c) asm(c b) "STREF";
forall X -> (tuple, X) ~tpop(tuple t) asm "TPOP";

(int, int) add_to_begin(int val, int cur_size, int char) {
    int new_val = (1 << cur_size) * char + val;
    return (new_val, cur_size + 8);
}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
    shift = shift % 26;
    shift = (shift + 26) % 26;
    slice cur_slice = text.begin_parse();
    int sz = slice_bits(cur_slice);

    cur_slice~skip_bits(32);
    sz -= 32;
    tuple characters = empty_tuple();
    characters~tpush(0);
    characters~tpush(0);
    characters~tpush(0);
    characters~tpush(0);

    while (sz > 0) {
        int char = cur_slice~load_uint(8);
        sz -= 8;
        if ((char >= 65) & (char <= 90)) {
            char = 65 + (char - 65 + shift) % 26;
        } elseif ((char >= 97) & (char <= 122)) {
            char = 97 + (char - 97 + shift) % 26;
        }
        characters~tpush(char);
    }
    while (cur_slice.slice_refs_empty?() != -1) {
        cell inner_cell = cur_slice~load_ref();
        cur_slice = inner_cell.begin_parse();
        sz = slice_bits(cur_slice);
        while (sz > 0) {
            int char = cur_slice~load_uint(8);
            sz -= 8;
            if ((char >= 65) & (char <= 90)) {
                char = 65 + (char - 65 + shift) % 26;
            } elseif ((char >= 97) & (char <= 122)) {
                char = 97 + (char - 97 + shift) % 26;
            }
            characters~tpush(char);
        }
    }
    int total_size = tlen(characters);
    int last_size = total_size % 127;
    if (last_size == 0) {
        last_size = 127;
    }
    builder cur_cell = begin_cell();
    while (total_size > 0) {
        total_size -= last_size;
        int now_val = 0;
        int now_size = 0;
        int was_last_size = last_size;
        while (last_size > 0) {
            int char = characters~tpop();
            (now_val, now_size) = add_to_begin(now_val, now_size, char);
            last_size -= 1;
        }
        cur_cell~store_uint(now_val, was_last_size * 8);
        last_size = 127;
        if (total_size > 0) {
            cell next_cell = cur_cell.end_cell();
            cur_cell = begin_cell();
            cur_cell = cur_cell.store_ref(next_cell);
        }
    }
    return cur_cell.end_cell();
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
    shift = shift % 26;
    shift = (shift + 26) % 26;
    shift = (26 - shift) % 26;
    slice cur_slice = text.begin_parse();
    int sz = slice_bits(cur_slice);

    cur_slice~skip_bits(32);
    sz -= 32;
    tuple characters = empty_tuple();
    characters~tpush(0);
    characters~tpush(0);
    characters~tpush(0);
    characters~tpush(0);

    while (sz > 0) {
        int char = cur_slice~load_uint(8);
        sz -= 8;
        if ((char >= 65) & (char <= 90)) {
            char = 65 + (char - 65 + shift) % 26;
        } elseif ((char >= 97) & (char <= 122)) {
            char = 97 + (char - 97 + shift) % 26;
        }
        characters~tpush(char);
    }
    while (cur_slice.slice_refs_empty?() != -1) {
        cell inner_cell = cur_slice~load_ref();
        cur_slice = inner_cell.begin_parse();
        sz = slice_bits(cur_slice);
        while (sz > 0) {
            int char = cur_slice~load_uint(8);
            sz -= 8;
            if ((char >= 65) & (char <= 90)) {
                char = 65 + (char - 65 + shift) % 26;
            } elseif ((char >= 97) & (char <= 122)) {
                char = 97 + (char - 97 + shift) % 26;
            }
            characters~tpush(char);
        }
    }
    int total_size = tlen(characters);
    int last_size = total_size % 127;
    if (last_size == 0) {
        last_size = 127;
    }
    builder cur_cell = begin_cell();
    while (total_size > 0) {
        total_size -= last_size;
        int now_val = 0;
        int now_size = 0;
        int was_last_size = last_size;
        while (last_size > 0) {
            int char = characters~tpop();
            (now_val, now_size) = add_to_begin(now_val, now_size, char);
            last_size -= 1;
        }
        cur_cell~store_uint(now_val, was_last_size * 8);
        last_size = 127;
        if (total_size > 0) {
            cell next_cell = cur_cell.end_cell();
            cur_cell = begin_cell();
            cur_cell = cur_cell.store_ref(next_cell);
        }
    }
    return cur_cell.end_cell();
}

